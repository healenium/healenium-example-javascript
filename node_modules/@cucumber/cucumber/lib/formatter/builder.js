"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const get_color_fns_1 = __importDefault(require("./get_color_fns"));
const javascript_snippet_syntax_1 = __importDefault(require("./step_definition_snippet_builder/javascript_snippet_syntax"));
const path_1 = __importDefault(require("path"));
const step_definition_snippet_builder_1 = __importDefault(require("./step_definition_snippet_builder"));
const value_checker_1 = require("../value_checker");
const snippet_syntax_1 = require("./step_definition_snippet_builder/snippet_syntax");
const url_1 = require("url");
const formatters_1 = __importDefault(require("./helpers/formatters"));
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { importer } = require('../importer');
const FormatterBuilder = {
    async build(type, options) {
        const FormatterConstructor = await FormatterBuilder.getConstructorByType(type, options.cwd);
        const colorFns = get_color_fns_1.default(options.parsedArgvOptions.colorsEnabled);
        const snippetBuilder = await FormatterBuilder.getStepDefinitionSnippetBuilder({
            cwd: options.cwd,
            snippetInterface: options.parsedArgvOptions.snippetInterface,
            snippetSyntax: options.parsedArgvOptions.snippetSyntax,
            supportCodeLibrary: options.supportCodeLibrary,
        });
        return new FormatterConstructor({
            colorFns,
            snippetBuilder,
            ...options,
        });
    },
    async getConstructorByType(type, cwd) {
        const formatters = formatters_1.default.getFormatters();
        return formatters[type]
            ? formatters[type]
            : await FormatterBuilder.loadCustomClass('formatter', type, cwd);
    },
    async getStepDefinitionSnippetBuilder({ cwd, snippetInterface, snippetSyntax, supportCodeLibrary, }) {
        if (value_checker_1.doesNotHaveValue(snippetInterface)) {
            snippetInterface = snippet_syntax_1.SnippetInterface.Synchronous;
        }
        let Syntax = javascript_snippet_syntax_1.default;
        if (value_checker_1.doesHaveValue(snippetSyntax)) {
            Syntax = await FormatterBuilder.loadCustomClass('syntax', snippetSyntax, cwd);
        }
        return new step_definition_snippet_builder_1.default({
            snippetSyntax: new Syntax(snippetInterface),
            parameterTypeRegistry: supportCodeLibrary.parameterTypeRegistry,
        });
    },
    async loadCustomClass(type, descriptor, cwd) {
        let CustomClass = descriptor.startsWith(`.`)
            ? await importer(url_1.pathToFileURL(path_1.default.resolve(cwd, descriptor)))
            : await importer(descriptor);
        CustomClass = FormatterBuilder.resolveConstructor(CustomClass);
        if (value_checker_1.doesHaveValue(CustomClass)) {
            return CustomClass;
        }
        else {
            throw new Error(`Custom ${type} (${descriptor}) does not export a function/class`);
        }
    },
    resolveConstructor(ImportedCode) {
        if (typeof ImportedCode === 'function') {
            return ImportedCode;
        }
        else if (value_checker_1.doesHaveValue(ImportedCode) &&
            typeof ImportedCode.default === 'function') {
            return ImportedCode.default;
        }
        return null;
    },
};
exports.default = FormatterBuilder;
//# sourceMappingURL=builder.js.map